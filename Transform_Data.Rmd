---
title: "Transform Data"
output: html_notebook
---

# Introduction

This work through builds on from **Tidy Data**. Here we explore more of babynames e.g. make plots by names of babies rather than just by gender.

Babynames is data on: The names of male and female babies born
in the US from 1880 to 2015. There are 1.8M rows of data!


```{r setup}
library(tidyverse)
library(babynames)
library(nycflights13)
# Toy datasets to use
pollution <- tribble(
       ~city,   ~size, ~amount, 
  "New York", "large",      23,
  "New York", "small",      14,
    "London", "large",      22,
    "London", "small",      16,
   "Beijing", "large",      121,
   "Beijing", "small",      56
)
band <- tribble(
   ~name,     ~band,
  "Mick",  "Stones",
  "John", "Beatles",
  "Paul", "Beatles"
)
instrument <- tribble(
    ~name,   ~plays,
   "John", "guitar",
   "Paul",   "bass",
  "Keith", "guitar"
)
instrument2 <- tribble(
    ~artist,   ~plays,
   "John", "guitar",
   "Paul",   "bass",
  "Keith", "guitar"
)
```

## babynames

```{r}
head(babynames, n = 3)
```


## Your Turn 1

You can isolate data by using:

**select()** - extract variables

**filter()** - extract cases

**arrange()** - reorder cases


Use select() to get just the `n` column:

```{r}
# select(babynames, name, n) # gives us names and n column
select(babynames, n) # this is just column n
```

## Quiz

Which of these is NOT a way to select the `name` and `n` columns together?

```{r}
select(babynames, -c(year, sex, prop)) # yes - this would work. The -c() REMOVES the columns specified
select(babynames, name:n) # yes - this would work. Names the columns we want to select from column "name"" through to column "n"
select(babynames, starts_with("n")) # yes - this would work as both columns "name" and "n" begin with the character "n"
select(babynames, ends_with("n")) # no - this would just get column "n"
select(babynames, contains("n")) # yes - only columns "name" and "n" contain the character "n"
```

Other useful things you can do with the select() function to extract the columns of interest are:

**matches()** - Select columns whose names match a regular expression. Note that regular expresssion should be in " ". In this example **select(data, matches("^.{4}$"))** would mean select columns which match with the regular expression of the same four characters. See here for more information on how regular expressions work! **This is a super useful topic https://regex101.com/ **

**one_of()** - Select columns whose names are one of a set for example **select(storms, one_of(c("storm", "storms", "Storm"))**

**num_range()** - Select columns named in prefix, number style for example **select(storms, num_range("x", 1:5))**



## Your Turn 2

Show:

* All of the names where prop is greater than or equal to 0.08  
* All of the children named "Sea"  
* All of the names that have a missing value for `n`  

To do this we need to use **filter()** which gives us the rows or interest. **NB:** select() gives us the columns of interet.

```{r}
filter(babynames, prop >= 0.08) # prop column values greater than or equal to 0.08

filter(babynames, name == "Sea") # name column which are called "Sea"

filter(babynames, is.na(n)) # there are no "na" values in column n

# an alternative approach would be to use subset()
subset(babynames, prop >= 0.08)

```

Useful terms:

**x < y** Less than

**x > y** Greater than

**x == y** Equal to

**x <= y** Less than or equal to

**x >= y** Greater than or equal to

**x != y** Not equal to

**x %in% y** Group membership e.g. group of names

**is.na(x)** Is NA

**!is.na(x)** Is not NA

```{r}
filter(babynames, name %in% c("Ben", "Alice", "Sarah"))
```


Note that you can also use multiple arguements with filter() such as name and year

```{r}
filter(babynames, name == "Emma", year == 1987)
```

Boolean operators enable us to specify multiple arguements in filter with more precision, such as using "and" and "or". Where:

**a & b** = and
**a | b** = or
**xor(a,b)** = "exclusive or". It is a logical operation that is true if and only if its arguments differ (one is true, the other is false). e.g. Returns true if a but not b; or if b but not a. Returns false if not a and not b; returns false if a and b. 
**!a** = not


## Your Turn 3

Use Boolean operators to alter the code below to return only the rows that contain:

* Girls named Sea  
* Names that were used by exactly 5 or 6 children in 1880  
* Names that are one of Acura, Lexus, or Yugo

```{r}
filter(babynames, name == "Sea" & sex == "F") # females with name Sea

filter(babynames, n == 5 | n == 6 & year == 1880) # n is 5 or 6 and year is 1880

filter(babynames, name %in% c("Acura", "Lexus", "Yugo"))
```


## Your Turn 4

Arrange babynames by `n`. Add `prop` as a second (tie breaking) variable to arrange on. Can you tell what the smallest value of `n` is?

```{r}
```

## Your Turn 5

Use `desc()` to find the names with the highest prop.
Then, use `desc()` to find the names with the highest n.

```{r}
```

## Your Turn 6

Use `%>%` to write a sequence of functions that: 

1. Filter babynames to just the girls that were born in 2015  
2. Select the `name` and `n` columns  
3. Arrange the results so that the most popular names are near the top.

```{r}
```

## Exam

1. Trim `babynames` to just the rows that contain your `name` and your `sex`  
2. Trim the result to just the columns that will appear in your graph (not strictly necessary, but useful practice)  
3. Plot the results as a line graph with `year` on the x axis and `prop` on the y axis

```{r}
```

## Your Turn 7

Use summarise() to compute three statistics about the data:

1. The first (minimum) year in the dataset  
2. The last (maximum) year in the dataset  
3. The total number of children represented in the data

```{r}
```

## Your Turn 8

Extract the rows where `name == "Khaleesi"`. Then use `summarise()` and a summary functions to find:

1. The total number of children named Khaleesi
2. The first year Khaleesi appeared in the data

```{r}
```

## Your Turn 9

Use `group_by()`, `summarise()`, and `arrange()` to display the ten most popular names. Compute popularity as the total number of children of a single gender given a name.

```{r}
```

## Your Turn 10

Use grouping to calculate and then plot the number of children born each year over time.

```{r}
```

## Your Turn 11

Use `min_rank()` and `mutate()` to rank each row in `babynames` from largest `n` to lowest `n`.

```{r}
```

## Your Turn 12

Compute each name's rank _within its year and sex_. 
Then compute the median rank _for each combination of name and sex_, and arrange the results from highest median rank to lowest.

```{r}
```

## Your Turn 13

Which airlines had the largest arrival delays? Complete the code below.

1. Join `airlines` to `flights`
2. Compute and order the average arrival delays by airline. Display full names, no codes.

```{r}
flights %>%
  drop_na(arr_delay) %>%
                      %>%
  group_by(         ) %>%
                      %>%
  arrange(       ) 
```

## Your Turn 14

How many airports in `airports` are serviced by flights originating in New York (i.e. flights in our dataset?) Notice that the column to join on is named `faa` in the **airports** data set and `dest` in the **flights** data set.


```{r}
__________ %>%
 _________(_________, by = ___________) %>%
  distinct(faa)
```



***

# Take aways

* Extract variables with `select()`  
* Extract cases with `filter()`  
* Arrange cases, with `arrange()`  

* Make tables of summaries with `summarise()`  
* Make new variables, with `mutate()`  
* Do groupwise operations with `group_by()`

* Connect operations with `%>%`  

* Use `left_join()`, `right_join()`, `full_join()`, or `inner_join()` to join datasets
* Use `semi_join()` or `anti_join()` to filter datasets against each other